From oadt Require Import lang_oadt.base.

Implicit Types (b : bool) (x X y Y : atom) (L : aset).

Open Scope type_scope.

(** * Definitions *)

(** ** Obliviousness label *)
(** Defined as alias of [bool]. An oblivious construct (with [LObliv] label) may
accept oblivious components, and a public construct (with [LPub] label) only
accepts public components. *)
Notation olabel := bool (only parsing).
Notation LObliv := true (only parsing).
Notation LPub := false (only parsing).

(** ** Leakage label *)
(** This corresponds to _leakage label_ in Fig. 16 in the paper. *)
(** Defined as alias of [bool]. A leaky expression (with [LLeak] label) may contain
potential leaks, and a safe expression (with [LSafe] label) doesn't. A leaky
expression need to be "fixed" by the [tape] construct in order for obliviousness
and they can not interfere types. We may use [‚ä§] for [LLeak] and [‚ä•] for
[LSafe]. *)
Notation llabel := bool (only parsing).
Notation LLeak := true (only parsing).
Notation LSafe := false (only parsing).

(** ** Expressions (e, œÑ) *)
(** This corresponds to _extended expressions_ in Fig. 16 which extends
_expressions_ in Fig. 9 in the paper. *)
(** We use locally nameless representation for binders. *)
Inductive expr :=
(* Locally bound variables, i.e. de Bruijn indices. *)
| EBVar (k : nat)
(* Free variables *)
| EFVar (x : atom)
(* Global variables, referring to global functions, ADTs and OADTs. *)
| EGVar (x : atom)
(* Simple types *)
| EUnitT
(* Public and oblivious Booleans *)
| EBool (l : olabel)
| EProd (œÑ1 œÑ2 : expr)
(* Public and oblivious sum *)
| ESum (l : olabel) (œÑ1 œÑ2 : expr)
(* Dependent function type *)
| EPi (l : llabel) (œÑ1 œÑ2: expr)
(* Unit and Boolean values *)
| EUnitV
| ELit (b : bool)
(* Function abstraction *)
| EAbs (l : llabel) (œÑ e : expr)
(* Expression and type application *)
| EApp (e1 e2 : expr)
(* Let binding *)
| ELet (e1 e2 : expr)
(* Public and oblivious conditional. The oblivious conditional may be leaky *)
| EIte (l : olabel) (e0 e1 e2 : expr)
(* Pair and projection *)
| EPair (e1 e2 : expr)
| EProj (b : bool) (e : expr)
(* Public and oblivious injection *)
| EInj (l : olabel) (b : bool) (œÑ e : expr)
(* Public and oblivious case. The oblivious case may be leaky *)
| ECase (l : olabel) (e0 : expr) (e1 : expr) (e2 : expr)
(* Iso-recursive type introduction and elimination *)
| EFold (X : atom) (e : expr)
| EUnfold (X : atom) (e : expr)
(* Boolean section *)
| ESec (e : expr)
(* Tape the leakage. *)
| ETape (e : expr)
(* Oblivious conditional, i.e. MUX. Technically we do not need this in the
source language, but it is a convenient machinery for a conceptually cleaner
semantics. *)
| EMux (e0 e1 e2 : expr)
(* Runtime expressions *)
| EBoxedLit (b : bool)
| EBoxedInj (b : bool) (œÑ e : expr)
.

(** [expr] has decidable equality. *)
Instance expr_eq : EqDecision expr.
Proof.
  solve_decision.
Defined.

(** ** Expressions with leakage label (T) *)
Definition lexpr := (llabel * expr).
Definition lexpr_label : lexpr -> llabel := fst.
Arguments lexpr_label /.
Definition lexpr_expr : lexpr -> expr := snd.
Arguments lexpr_expr /.

(** ** Global definitions (D) *)
(** This corresponds to _extended global definition_ in Fig. 16 which extends
_global definitions_ in Fig. 9 in the paper. *)
Variant gdef :=
| DADT (e : expr)
| DFun (T : lexpr) (e : expr)
| DOADT (œÑ e : expr)
.

(** ** Global context (Œ£) *)
(** A store of global definitions. *)
Notation gctx := (amap gdef).

(** ** Programs (P) *)
Notation program := (gctx * expr).


(** * Notations for expressions *)
Module expr_notations.

(* Adapted from _Software Foundations_. *)
Coercion ELit : bool >-> expr.
Coercion lexpr_expr : lexpr >-> expr.

(** Quote *)
Notation "<{ e }>" := e (e custom oadt at level 99).
(** Lispy unquote *)
Notation "',(' e ')'" := e (in custom oadt at level 0,
                               e constr at level 0).

Notation "( x )" := x (in custom oadt, x at level 99).
Notation "x" := x (in custom oadt at level 0, x constr at level 0).
Notation "'bvar' x" := (EBVar x) (in custom oadt at level 0, x constr at level 0).
Notation "'fvar' x" := (EFVar x) (in custom oadt at level 0, x constr at level 0,
                                     only parsing).
Notation "'gvar' x" := (EGVar x) (in custom oadt at level 0, x constr at level 0).
Notation "'lit' b" := (ELit b) (in custom oadt at level 0, b constr at level 0,
                                   only parsing).
Notation "'ùüô'" := EUnitT (in custom oadt at level 0).
Notation "'Unit'" := EUnitT (in custom oadt at level 0, only parsing).
Notation "'ùîπ{' l '}'" := (EBool l) (in custom oadt at level 0,
                                       l constr at level 0,
                                       format "'ùîπ{' l '}'").
Notation "'ùîπ'" := (EBool LPub) (in custom oadt at level 0).
Notation "'Bool'" := (EBool LPub) (in custom oadt at level 0, only parsing).
Notation "'~ùîπ'" := (EBool LObliv) (in custom oadt at level 0).
Notation "'~Bool'" := (EBool LObliv) (in custom oadt at level 0, only parsing).
Notation "œÑ1 * œÑ2" := (EProd œÑ1 œÑ2) (in custom oadt at level 3,
                                        œÑ1 custom oadt,
                                        œÑ2 custom oadt at level 0).
Notation "œÑ1 '+{' l '}' œÑ2" := (ESum l œÑ1 œÑ2) (in custom oadt at level 4,
                                                  l constr at level 0,
                                                  left associativity,
                                                  format "œÑ1  '+{' l '}'  œÑ2").
Notation "œÑ1 + œÑ2" := (ESum LPub œÑ1 œÑ2) (in custom oadt at level 4,
                                            left associativity).
Notation "œÑ1 ~+ œÑ2" := (ESum LObliv œÑ1 œÑ2) (in custom oadt at level 4,
                                               left associativity).
Notation "'Œ†' :{ l } œÑ1 , œÑ2" := (EPi l œÑ1 œÑ2)
                                   (in custom oadt at level 50,
                                       right associativity,
                                       format "Œ† :{ l } œÑ1 ,  œÑ2").
Notation "'Œ†' : œÑ1 , œÑ2" := (EPi LSafe œÑ1 œÑ2)
                              (in custom oadt at level 50,
                                  right associativity,
                                  format "Œ† : œÑ1 ,  œÑ2").
Notation "'Œ†' ~: œÑ1 , œÑ2" := (EPi LLeak œÑ1 œÑ2)
                               (in custom oadt at level 50,
                                   right associativity,
                                   format "Œ† ~: œÑ1 ,  œÑ2").
Notation "\ :{ l } œÑ '=>' e" := (EAbs l œÑ e)
                                  (in custom oadt at level 90,
                                      œÑ custom oadt at level 99,
                                      e custom oadt at level 99,
                                      left associativity,
                                      format "\ :{ l } œÑ  =>  e").
Notation "\ : œÑ '=>' e" := (EAbs LSafe œÑ e)
                             (in custom oadt at level 90,
                                 œÑ custom oadt at level 99,
                                 e custom oadt at level 99,
                                 left associativity,
                                 format "\ : œÑ  =>  e").
Notation "\ ~: œÑ '=>' e" := (EAbs LLeak œÑ e)
                              (in custom oadt at level 90,
                                  œÑ custom oadt at level 99,
                                  e custom oadt at level 99,
                                  left associativity,
                                  format "\ ~: œÑ  =>  e").
Notation "e1 e2" := (EApp e1 e2) (in custom oadt at level 2, left associativity).
Notation "()" := EUnitV (in custom oadt at level 0).
Notation "( x , y , .. , z )" := (EPair .. (EPair x y) .. z)
                                   (in custom oadt at level 0,
                                       x custom oadt at level 99,
                                       y custom oadt at level 99,
                                       z custom oadt at level 99).
Notation "'œÄ@' b e" := (EProj b e) (in custom oadt at level 2,
                                       b constr at level 0,
                                       format "œÄ@ b  e").
Notation "'œÄ1' e" := (EProj true e) (in custom oadt at level 2).
Notation "'œÄ2' e" := (EProj false e) (in custom oadt at level 2).
Notation "'sùîπ' e" := (ESec e) (in custom oadt at level 2).
Notation "'if{' l '}' e0 'then' e1 'else' e2" := (EIte l e0 e1 e2)
                                                   (in custom oadt at level 89,
                                                       l constr at level 0,
                                                       e0 custom oadt at level 99,
                                                       e1 custom oadt at level 99,
                                                       e2 custom oadt at level 99,
                                                       left associativity,
                                                       format "'if{' l '}'  e0  'then'  e1  'else'  e2").
Notation "'if' e0 'then' e1 'else' e2" := (EIte LPub e0 e1 e2)
                                            (in custom oadt at level 89,
                                                e0 custom oadt at level 99,
                                                e1 custom oadt at level 99,
                                                e2 custom oadt at level 99,
                                                left associativity).
Notation "'~if' e0 'then' e1 'else' e2" := (EIte LObliv e0 e1 e2)
                                             (in custom oadt at level 89,
                                                 e0 custom oadt at level 99,
                                                 e1 custom oadt at level 99,
                                                 e2 custom oadt at level 99).
Notation "'let' e1 'in' e2" := (ELet e1 e2)
                                 (in custom oadt at level 0,
                                     e1 custom oadt at level 99,
                                     e2 custom oadt at level 99).
Notation "'inj{' l '}@' b < œÑ > e" := (EInj l b œÑ e) (in custom oadt at level 2,
                                                         l constr at level 0,
                                                         b constr at level 0,
                                                         œÑ custom oadt at level 0,
                                                         format "'inj{' l '}@' b < œÑ >  e").
Notation "'inl{' l '}' < œÑ > e" := (EInj l true œÑ e) (in custom oadt at level 2,
                                                         œÑ custom oadt at level 0,
                                                         format "inl{ l } < œÑ >  e").
Notation "'inr{' l '}' < œÑ > e" := (EInj l false œÑ e) (in custom oadt at level 2,
                                                          œÑ custom oadt at level 0,
                                                          format "inr{ l } < œÑ >  e").
Notation "'inj@' b < œÑ > e" := (EInj LPub b œÑ e) (in custom oadt at level 2,
                                                     b constr at level 0,
                                                     œÑ custom oadt at level 0,
                                                     format "inj@ b < œÑ >  e").
Notation "'inl' < œÑ > e" := (EInj LPub true œÑ e) (in custom oadt at level 2,
                                                     œÑ custom oadt at level 0,
                                                     format "inl < œÑ >  e").
Notation "'inr' < œÑ > e" := (EInj LPub false œÑ e) (in custom oadt at level 2,
                                                      œÑ custom oadt at level 0,
                                                      format "inr < œÑ >  e").
Notation "'~inj@' b < œÑ > e" := (EInj LObliv b œÑ e) (in custom oadt at level 2,
                                                        b constr at level 0,
                                                        œÑ custom oadt at level 0,
                                                        format "~inj@ b < œÑ >  e").
Notation "'~inl' < œÑ > e" := (EInj LObliv true œÑ e) (in custom oadt at level 2,
                                                        œÑ custom oadt at level 0,
                                                        format "~inl < œÑ >  e").
Notation "'~inr' < œÑ > e" := (EInj LObliv false œÑ e) (in custom oadt at level 2,
                                                         œÑ custom oadt at level 0,
                                                         format "~inr < œÑ >  e").
Notation "'case{' l '}' e0 'of' e1 '|' e2" :=
  (ECase l e0 e1 e2) (in custom oadt at level 89,
                         l constr at level 0,
                         e0 custom oadt at level 99,
                         e1 custom oadt at level 99,
                         e2 custom oadt at level 99,
                         left associativity,
                         format "'case{' l '}'  e0  'of'  e1  '|'  e2").
Notation "'case' e0 'of' e1 '|' e2" :=
  (ECase LPub e0 e1 e2) (in custom oadt at level 89,
                            e0 custom oadt at level 99,
                            e1 custom oadt at level 99,
                            e2 custom oadt at level 99,
                            left associativity).
Notation "'~case' e0 'of' e1 '|' e2" :=
  (ECase LObliv e0 e1 e2) (in custom oadt at level 89,
                              e0 custom oadt at level 99,
                              e1 custom oadt at level 99,
                              e2 custom oadt at level 99,
                              left associativity).
Notation "'fold' < X > e" := (EFold X e) (in custom oadt at level 2,
                                             X custom oadt at level 0,
                                             format "fold < X >  e").
Notation "'unfold' < X > e" := (EUnfold X e) (in custom oadt at level 2,
                                                 X custom oadt at level 0,
                                                 format "unfold < X >  e").
Notation "'tape' e" := (ETape e) (in custom oadt at level 2).
Notation "'mux' e0 e1 e2" := (EMux e0 e1 e2) (in custom oadt at level 2,
                                                 e0 custom oadt at level 0,
                                                 e1 custom oadt at level 0,
                                                 e2 custom oadt at level 0).

Notation "[ b ]" := (EBoxedLit b) (in custom oadt at level 0,
                                      b constr at level 0).
Notation "[ 'inj@' b < œÑ > e ]" := (EBoxedInj b œÑ e)
                                     (in custom oadt at level 0,
                                         b constr at level 0,
                                         œÑ custom oadt at level 0,
                                         e custom oadt at level 0,
                                         format "[ inj@ b < œÑ >  e ]").
Notation "[ 'inl' < œÑ > e ]" := (EBoxedInj true œÑ e)
                                  (in custom oadt at level 0,
                                      œÑ custom oadt at level 0,
                                      e custom oadt at level 0,
                                      format "[ inl < œÑ >  e ]").
Notation "[ 'inr' < œÑ > e ]" := (EBoxedInj false œÑ e)
                                  (in custom oadt at level 0,
                                      œÑ custom oadt at level 0,
                                      e custom oadt at level 0,
                                      format "[ inr < œÑ >  e ]").

Notation "'ite' e0 e1 e2" := (if e0 then e1 else e2)
                               (in custom oadt at level 2,
                                   e0 constr at level 0,
                                   e1 custom oadt at level 0,
                                   e2 custom oadt at level 0).

(** Boolean retraction. *)
Notation "'rùîπ' e" := <{ ~if e then true else false }> (in custom oadt at level 2).

End expr_notations.


(** * More Definitions *)
Section definitions.

Import expr_notations.
#[local]
Coercion EFVar : atom >-> expr.

(** ** Indistinguishability *)

(** This corresponds to Definition 3.6 (Indistinguishability) in the paper,
extended to handle leakage labels. *)
(** Instead of formalizing an observe function and considering two expressions
indistinguishable if they are observed the same, we directly formalize the
indistinguishability relation as the equivalence induced by the observe
function.

All rules but the rules for boxed expressions are just congruence rules. Some
rules are not necessary if the expressions are well-typed, but we include them
anyway. *)
Reserved Notation "e '‚âà' e'" (at level 40).

Inductive indistinguishable : expr -> expr -> Prop :=
| IBVar k : <{ bvar k }> ‚âà <{ bvar k }>
| IFVar x : <{ fvar x }> ‚âà <{ fvar x }>
| IGVar x : <{ gvar x }> ‚âà <{ gvar x }>
| IPi l œÑ1 œÑ1' œÑ2 œÑ2' :
    œÑ1 ‚âà œÑ1' ->
    œÑ2 ‚âà œÑ2' ->
    <{ Œ†:{l}œÑ1, œÑ2 }> ‚âà <{ Œ†:{l}œÑ1', œÑ2' }>
| IAbs l œÑ œÑ' e e' :
    œÑ ‚âà œÑ' ->
    e ‚âà e' ->
    <{ \:{l}œÑ => e }> ‚âà <{ \:{l}œÑ' => e' }>
| IApp e1 e1' e2 e2' :
    e1 ‚âà e1' ->
    e2 ‚âà e2' ->
    <{ e1 e2 }> ‚âà <{ e1' e2' }>
| ILet e1 e1' e2 e2' :
    e1 ‚âà e1' ->
    e2 ‚âà e2' ->
    <{ let e1 in e2 }> ‚âà <{ let e1' in e2' }>
| IUnitT : <{ ùüô }> ‚âà <{ ùüô }>
| IUnitV : <{ () }> ‚âà <{ () }>
| IBool l : <{ ùîπ{l} }> ‚âà <{ ùîπ{l} }>
| ILit b : <{ lit b }> ‚âà <{ lit b }>
| ISec e e' :
    e ‚âà e' ->
    <{ sùîπ e }> ‚âà <{ sùîπ e' }>
| IIte l e0 e0' e1 e1' e2 e2' :
    e0 ‚âà e0' ->
    e1 ‚âà e1' ->
    e2 ‚âà e2' ->
    <{ if{l} e0 then e1 else e2 }> ‚âà <{ if{l} e0' then e1' else e2' }>
| IProd œÑ1 œÑ1' œÑ2 œÑ2' :
    œÑ1 ‚âà œÑ1' ->
    œÑ2 ‚âà œÑ2' ->
    <{ œÑ1 * œÑ2 }> ‚âà <{ œÑ1' * œÑ2' }>
| IPair e1 e1' e2 e2' :
    e1 ‚âà e1' ->
    e2 ‚âà e2' ->
    <{ (e1, e2) }> ‚âà <{ (e1', e2') }>
| IProj b e e' :
    e ‚âà e' ->
    <{ œÄ@b e }> ‚âà <{ œÄ@b e' }>
| ISum l œÑ1 œÑ1' œÑ2 œÑ2' :
    œÑ1 ‚âà œÑ1' ->
    œÑ2 ‚âà œÑ2' ->
    <{ œÑ1 +{l} œÑ2 }> ‚âà <{ œÑ1' +{l} œÑ2' }>
| IInj l b œÑ œÑ' e e' :
    œÑ ‚âà œÑ' ->
    e ‚âà e' ->
    <{ inj{l}@b<œÑ> e }> ‚âà <{ inj{l}@b<œÑ'> e' }>
| ICase l e0 e0' e1 e1' e2 e2' :
    e0 ‚âà e0' ->
    e1 ‚âà e1' ->
    e2 ‚âà e2' ->
    <{ case{l} e0 of e1 | e2 }> ‚âà <{ case{l} e0' of e1' | e2' }>
| IFold X e e' :
    e ‚âà e' ->
    <{ fold<X> e }> ‚âà <{ fold<X> e' }>
| IUnfold X e e' :
    e ‚âà e' ->
    <{ unfold<X> e }> ‚âà <{ unfold<X> e' }>
| ITape e e' :
    e ‚âà e' ->
    <{ tape e }> ‚âà <{ tape e' }>
| IMux e0 e0' e1 e1' e2 e2' :
    e0 ‚âà e0' ->
    e1 ‚âà e1' ->
    e2 ‚âà e2' ->
    <{ mux e0 e1 e2 }> ‚âà <{ mux e0' e1' e2' }>
(* The only interesting cases *)
| IBoxedLit b b' :
    (* We can not distinguish between two encrypted boolean values. *)
    <{ [b] }> ‚âà <{ [b'] }>
| IBoxedInj b b' œÑ e e' :
    (* We can not tell which branch an encrypted sum injects to nor what the
    encrypted value is. But the type information is public so we need to make
    sure nothing leaked from this type information. Technically we only need the
    two types to be indistinguishable, but the stronger notion of equality also
    works. *)
    <{ [inj@b<œÑ> e] }> ‚âà <{ [inj@b'<œÑ> e'] }>

where "e '‚âà' e'" := (indistinguishable e e').

(** ** Variable opening  *)
Reserved Notation "'{' k '~>' s '}' e" (in custom oadt at level 20, k constr).

Fixpoint open_ (k : nat) (s : expr) (e : expr) : expr :=
  match e with
  | <{ bvar n }> => if decide (k = n) then s else e
  | <{ Œ†:{l}œÑ1, œÑ2 }> => <{ Œ†:{l}({k~>s}œÑ1), {S k~>s}œÑ2 }>
  | <{ \:{l}œÑ => e }> => <{ \:{l}({k~>s}œÑ) => {S k~>s}e }>
  | <{ let e1 in e2 }> => <{ let {k~>s}e1 in {S k~>s}e2 }>
  | <{ case{l} e0 of e1 | e2 }> => <{ case{l} {k~>s}e0 of {S k~>s}e1 | {S k~>s}e2 }>
  (* Congruence rules *)
  | <{ e1 e2 }> => <{ ({k~>s}e1) ({k~>s}e2) }>
  | <{ sùîπ e }> => <{ sùîπ ({k~>s}e) }>
  | <{ if{l} e0 then e1 else e2 }> => <{ if{l} {k~>s}e0 then {k~>s}e1 else {k~>s}e2 }>
  | <{ œÑ1 * œÑ2 }> => <{ ({k~>s}œÑ1) * ({k~>s}œÑ2) }>
  | <{ (e1, e2) }> => <{ ({k~>s}e1, {k~>s}e2) }>
  | <{ œÄ@b e }> => <{ œÄ@b ({k~>s}e) }>
  | <{ œÑ1 +{l} œÑ2 }> => <{ ({k~>s}œÑ1) +{l} ({k~>s}œÑ2) }>
  | <{ inj{l}@b<œÑ> e }> => <{ inj{l}@b<({k~>s}œÑ)> ({k~>s}e) }>
  | <{ fold<X> e }> => <{ fold<X> ({k~>s}e) }>
  | <{ unfold<X> e }> => <{ unfold<X> ({k~>s}e) }>
  | <{ tape e }> => <{ tape ({k~>s}e) }>
  | <{ mux e0 e1 e2 }> => <{ mux ({k~>s}e0) ({k~>s}e1) ({k~>s}e2) }>
  | _ => e
  end

where "'{' k '~>' s '}' e" := (open_ k s e) (in custom oadt).

Definition open s e := open_ 0 s e.
Notation "e ^ s" := (open s e) (in custom oadt at level 20).

(** ** Substitution *)
Reserved Notation "'{' x '‚Ü¶' s '}' e" (in custom oadt at level 20, x constr).

Fixpoint subst (x : atom) (s : expr) (e : expr) : expr :=
  match e with
  | <{ fvar y }> => if decide (x = y) then s else e
  (* Congruence rules *)
  | <{ Œ†:{l}œÑ1, œÑ2 }> => <{ Œ†:{l}({x‚Ü¶s}œÑ1), {x‚Ü¶s}œÑ2 }>
  | <{ \:{l}œÑ => e }> => <{ \:{l}({x‚Ü¶s}œÑ) => {x‚Ü¶s}e }>
  | <{ e1 e2 }> => <{ ({x‚Ü¶s}e1) ({x‚Ü¶s}e2) }>
  | <{ let e1 in e2 }> => <{ let {x‚Ü¶s}e1 in {x‚Ü¶s}e2 }>
  | <{ sùîπ e }> => <{ sùîπ ({x‚Ü¶s}e) }>
  | <{ if{l} e0 then e1 else e2 }> => <{ if{l} {x‚Ü¶s}e0 then {x‚Ü¶s}e1 else {x‚Ü¶s}e2 }>
  | <{ œÑ1 * œÑ2 }> => <{ ({x‚Ü¶s}œÑ1) * ({x‚Ü¶s}œÑ2) }>
  | <{ (e1, e2) }> => <{ ({x‚Ü¶s}e1, {x‚Ü¶s}e2) }>
  | <{ œÄ@b e }> => <{ œÄ@b ({x‚Ü¶s}e) }>
  | <{ œÑ1 +{l} œÑ2 }> => <{ ({x‚Ü¶s}œÑ1) +{l} ({x‚Ü¶s}œÑ2) }>
  | <{ inj{l}@b<œÑ> e }> => <{ inj{l}@b<({x‚Ü¶s}œÑ)> ({x‚Ü¶s}e) }>
  | <{ case{l} e0 of e1 | e2 }> => <{ case{l} {x‚Ü¶s}e0 of {x‚Ü¶s}e1 | {x‚Ü¶s}e2 }>
  | <{ fold<X> e }> => <{ fold<X> ({x‚Ü¶s}e) }>
  | <{ unfold<X> e }> => <{ unfold<X> ({x‚Ü¶s}e) }>
  | <{ tape e }> => <{ tape ({x‚Ü¶s}e) }>
  | <{ mux e0 e1 e2 }> => <{ mux ({x‚Ü¶s}e0) ({x‚Ü¶s}e1) ({x‚Ü¶s}e2) }>
  | _ => e
  end

where "'{' x '‚Ü¶' s '}' e" := (subst x s e) (in custom oadt).

Definition lexpr_subst x s (T : lexpr) := (T.1, subst x s T.2).

(** ** Oblivious type values (œâ) *)
(** This corresponds to oblivious type values in Fig. 9 in the paper. *)
Inductive otval : expr -> Prop :=
| OVUnitT : otval <{ ùüô }>
| OVOBool : otval <{ ~ùîπ }>
| OVProd œâ1 œâ2 : otval œâ1 -> otval œâ2 -> otval <{ œâ1 * œâ2 }>
| OVOSum œâ1 œâ2 : otval œâ1 -> otval œâ2 -> otval <{ œâ1 ~+ œâ2 }>
.

(** ** Oblivious values (v) *)
(** This corresponds to oblivious values in Fig. 9 in the paper. *)
Inductive oval : expr -> Prop :=
| OVUnitV : oval <{ () }>
| OVBoxedLit b : oval <{ [b] }>
| OVPair v1 v2 : oval v1 -> oval v2 -> oval <{ (v1, v2) }>
| OVBoxedInj b œâ v : otval œâ -> oval v -> oval <{ [inj@b<œâ> v] }>
.

(** ** Values (v) *)
(** This corresponds to values in Fig. 9 in the paper, extended to handle
leakage labels. *)
Inductive val : expr -> Prop :=
| VUnitV : val <{ () }>
| VLit b : val <{ lit b }>
| VPair v1 v2 : val v1 -> val v2 -> val <{ (v1, v2) }>
| VAbs l œÑ e : val <{ \:{l}œÑ => e }>
| VInj b œÑ v : val v -> val <{ inj@b<œÑ> v }>
| VFold X v : val v -> val <{ fold<X> v }>
| VBoxedLit b : val <{ [b] }>
| VBoxedInj b œâ v : otval œâ -> oval v -> val <{ [inj@b<œâ> v] }>
.

(** ** Local closure and well-formedness of expressions *)
Inductive lc : expr -> Prop :=
| LCFVar x : lc <{ fvar x }>
| LCGVar x : lc <{ gvar x }>
| LCPi l œÑ1 œÑ2 L :
    (forall x, x ‚àâ L -> lc <{ œÑ2^x }>) ->
    lc œÑ1 -> lc <{ Œ†:{l}œÑ1, œÑ2 }>
| LCAbs l œÑ e L :
    (forall x, x ‚àâ L -> lc <{ e^x }>) ->
    lc œÑ -> lc <{ \:{l}œÑ => e }>
| LCLet e1 e2 L :
    (forall x, x ‚àâ L -> lc <{ e2^x }>) ->
    lc e1 -> lc <{ let e1 in e2 }>
| LCCase l e0 e1 e2 L1 L2 :
    (forall x, x ‚àâ L1 -> lc <{ e1^x }>) ->
    (forall x, x ‚àâ L2 -> lc <{ e2^x }>) ->
    lc e0 -> lc <{ case{l} e0 of e1 | e2 }>
(* Congruence rules *)
| LCUnitT : lc <{ ùüô }>
| LCUnitV : lc <{ () }>
| LCBool l : lc <{ ùîπ{l} }>
| LCApp e1 e2 : lc e1 -> lc e2 -> lc <{ e1 e2 }>
| LCLit b : lc <{ lit b }>
| LCSec e : lc e -> lc <{ sùîπ e }>
| LCIte l e0 e1 e2 : lc e0 -> lc e1 -> lc e2 -> lc <{ if{l} e0 then e1 else e2 }>
| LCProd œÑ1 œÑ2 : lc œÑ1 -> lc œÑ2 -> lc <{ œÑ1 * œÑ2 }>
| LCPair e1 e2 : lc e1 -> lc e2 -> lc <{ (e1, e2) }>
| LCProj b e : lc e -> lc <{ œÄ@b e }>
| LCSum l œÑ1 œÑ2 : lc œÑ1 -> lc œÑ2 -> lc <{ œÑ1 +{l} œÑ2 }>
| LCInj l b œÑ e : lc œÑ -> lc e -> lc <{ inj{l}@b<œÑ> e }>
| LCFold X e : lc e -> lc <{ fold<X> e }>
| LCUnfold X e : lc e -> lc <{ unfold<X> e }>
| LCTape e : lc e -> lc <{ tape e }>
| LCMux e0 e1 e2 : lc e0 -> lc e1 -> lc e2 -> lc <{ mux e0 e1 e2 }>
| LCBoxedLit b : lc <{ [b] }>
(* Techincally this is not only locally closed, but more about
well-formedness. *)
| LCBoxedInj b œâ v : otval œâ -> oval v -> lc <{ [inj@b<œâ> v] }>
.

End definitions.

(** * Notations *)
Module notations.

Export expr_notations.

Notation "e '‚âà' e'" := (indistinguishable e e') (at level 40).

Notation "'{' k '~>' s '}' e" := (open_ k s e)
                                   (in custom oadt at level 20, k constr).
Notation "e ^ s" := (open s e) (in custom oadt at level 20).

Notation "'{' x '‚Ü¶' s '}' e" := (subst x s e)
                                  (in custom oadt at level 20, x constr).
(* This notation is supposed to be applied to a typing context. *)
Notation "{ x '‚Ü¶' s }" := (lexpr_subst x s) (at level 20).

Notation "x # s" := (x ‚àâ stale s) (at level 40).

End notations.
